'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
* @class
*/
var Engine = function () {
    /**
    * @constructor
    */
    function Engine() {
        _classCallCheck(this, Engine);

        if (Engine.instance instanceof Engine) {
            console.error('Engine.constructor: Engine instance already exists.');
            return null;
        }

        Engine.instance = this;

        this.lastTime = Date.now();
        this.callbackSet = new Set();
        this.keyCallbackSet = new Set();
        this.mouseCallbackSet = new Set();

        document.addEventListener('keyup', this.handleKeyEvents.bind(this));
        document.addEventListener('keydown', this.handleKeyEvents.bind(this));
        document.addEventListener('keypress', this.handleKeyEvents.bind(this));

        if (!Render) {
            console.error('Engine.constructor: Render class is not defined.');
        } else if (!(Render.instance instanceof Render)) {
            console.error('Engine.constructor: There is no render instance to subscribre mouse events.');
        } else {
            this.render = Render.instance;

            this.render.canvas.addEventListener('mouseover', this.handleMouseEvents.bind(this));
            this.render.canvas.addEventListener('mousemove', this.handleMouseEvents.bind(this));
            this.render.canvas.addEventListener('mouseleave', this.handleMouseEvents.bind(this));
            this.render.canvas.addEventListener('mouseout', this.handleMouseEvents.bind(this));
            this.render.canvas.addEventListener('click', this.handleMouseEvents.bind(this));
            this.render.canvas.addEventListener('auxclick', this.handleMouseEvents.bind(this));
            this.render.canvas.addEventListener('mousedown', this.handleMouseEvents.bind(this));
            this.render.canvas.addEventListener('mouseup', this.handleMouseEvents.bind(this));
        }
    }

    _createClass(Engine, [{
        key: 'handleKeyEvents',
        value: function handleKeyEvents(event) {
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = this.keyCallbackSet[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var callback = _step.value;

                    callback(event);
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator.return) {
                        _iterator.return();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
        }
    }, {
        key: 'handleMouseEvents',
        value: function handleMouseEvents(event) {
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
                for (var _iterator2 = this.mouseCallbackSet[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                    var callback = _step2.value;

                    callback(event);
                }
            } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion2 && _iterator2.return) {
                        _iterator2.return();
                    }
                } finally {
                    if (_didIteratorError2) {
                        throw _iteratorError2;
                    }
                }
            }
        }
    }, {
        key: 'start',
        value: function start() {
            requestAnimationFrame(this.routine.bind(this));
        }
    }, {
        key: 'routine',
        value: function routine() {
            var deltaTime = this.currentTime - this.lastTime;

            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = undefined;

            try {
                for (var _iterator3 = this.callbackSet[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                    var callback = _step3.value;

                    callback(deltaTime);
                }
            } catch (err) {
                _didIteratorError3 = true;
                _iteratorError3 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion3 && _iterator3.return) {
                        _iterator3.return();
                    }
                } finally {
                    if (_didIteratorError3) {
                        throw _iteratorError3;
                    }
                }
            }

            this.render.render();

            requestAnimationFrame(this.routine.bind(this));
        }

        /**
        * @callback routineCallback
        * @param {number} deltaTime - time since the callback was last called.
        */

        /**
        * @method registerRoutineCallback - add a callback to be invoked by the engine.
        * @param {routineCallback} callback
        */

    }, {
        key: 'registerRoutineCallback',
        value: function registerRoutineCallback(callback) {
            if (typeof callback == 'function') {
                this.callbackSet.add(callback);
            } else {
                console.error('Engine.registerRoutineCallback: callback is not set as a function.');
            }
        }
    }, {
        key: 'registerKeyEventCallback',
        value: function registerKeyEventCallback(callback) {
            if (typeof callback == 'function') {
                this.keyCallbackSet.add(callback);
            } else {
                console.error('Engine.registerKeyEventCallback: callback is not set as a function.');
            }
        }
    }, {
        key: 'registerMouseEventCallback',
        value: function registerMouseEventCallback(callback) {
            if (typeof callback == 'function') {
                this.mouseCallbackSet.add(callback);
            } else {
                console.error('Engine.registerMouseEventCallback: callback is not set as a function.');
            }
        }
    }, {
        key: 'currentTime',
        get: function get() {
            return Date.now();
        }
    }]);

    return Engine;
}();
"use strict";

var flat = {};
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
* @class
*/
var ImageObject = function () {
    /**
    * @constructor
    */
    function ImageObject(sprite) {
        var subscribeToRender = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

        _classCallCheck(this, ImageObject);

        if (sprite instanceof Image) {
            this.sprite = sprite;

            this.originalsizeX = sprite.width;
            this.originalsizeY = sprite.height;
        } else if (sprite) {
            console.error('GameObject.constructor: sprite is not set as a Image object.');
        }

        this.pivotX = 0.5;
        this.pivotY = 0.5;

        this.x = 0;
        this.y = 0;

        this.originalsizeX = this.originalsizeX || 0;
        this.originalsizeY = this.originalsizeY || 0;

        this.scaleX = 1;
        this.scaleY = 1;

        this.layer = 0;

        if (subscribeToRender) {
            if (!Render) {
                console.error('ImageObject.constructor: Render class is not defined.');
            } else if (!(Render.instance instanceof Render)) {
                console.error('ImageObject.constructor: There is no render instance to subscribre to.');
            } else {
                Render.instance.registerObject(this);
            }
        }
    }

    _createClass(ImageObject, [{
        key: 'pivot',
        get: function get() {
            return [this.pivotX, this.pivotY];
        },
        set: function set(pivot) {
            if (pivot instanceof Array && pivot.length == 2 && typeof pivot[0] == 'number' && typeof pivot[1] == 'number') {
                this.pivotX = pivot[0];
                this.pivotY = pivot[1];
            } else {
                console.error('set ImageObject.pivot: pivot is not an array of size 2 that contains numbers.');
            }
        }
    }, {
        key: 'position',
        get: function get() {
            return [this.x, this.y];
        },
        set: function set(position) {
            if (position instanceof Array && position.length == 2 && typeof position[0] == 'number' && typeof position[1] == 'number') {
                this.x = position[0];
                this.y = position[1];
            } else {
                console.error('set ImageObject.position: position is not an array of size 2 that contains numbers.');
            }
        }
    }, {
        key: 'sizeX',
        get: function get() {
            return this.originalsizeX * this.scaleX;
        }
    }, {
        key: 'sizeY',
        get: function get() {
            return this.originalsizeY * this.scaleY;
        }
    }, {
        key: 'size',
        get: function get() {
            return [this.originalsizeX * this.scaleX, this.originalsizeY * this.scaleY];
        }
    }, {
        key: 'originalsize',
        get: function get() {
            return [this.originalsizeX, this.originalsizeY];
        },
        set: function set(originalsize) {
            if (originalsize instanceof Array && originalsize.length == 2 && typeof originalsize[0] == 'number' && typeof originalsize[1] == 'number') {
                this.originalsizeX = originalsize[0];
                this.originalsizeY = originalsize[1];
            } else {
                console.error('set ImageObject.originalsize: originalsize is not an array of size 2 that contains numbers.');
            }
        }
    }, {
        key: 'scale',
        get: function get() {
            return [this.scaleX, this.scaleY];
        },
        set: function set(scale) {
            if (scale instanceof Array && scale.length == 2 && typeof scale[0] == 'number' && typeof scale[1] == 'number') {
                this.scaleX = scale[0];
                this.scaleY = scale[1];
            } else if (typeof scale == 'number') {
                this.scaleX = scale;
                this.scaleY = scale;
            } else {
                console.error('set ImageObject.scale: scale is not an array of size 2 that contains numbers or simply a number.');
            }
        }
    }]);

    return ImageObject;
}();

/**
* @class
*/


var GameObject = function (_ImageObject) {
    _inherits(GameObject, _ImageObject);

    /**
    * @constructor
    */
    function GameObject(sprite) {
        var subscribeToRender = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

        _classCallCheck(this, GameObject);

        var _this = _possibleConstructorReturn(this, (GameObject.__proto__ || Object.getPrototypeOf(GameObject)).call(this, sprite, subscribeToRender));

        _this.vx = 0;
        _this.vy = 0;

        _this.originalBorderWidth = _this.originalsizeX || 64;
        _this.originalBorderHeight = _this.originalsizeY || 64;
        // // Box colider
        // this.boxColliderSize = [0, 0];
        // this.boxColliderPositionOffset = [0, 0];
        //
        // this.active = true;
        return _this;
    }

    _createClass(GameObject, [{
        key: 'update',
        value: function update(deltaTime) {
            if (this.active) {
                this.x += this.vx * deltaTime;
                this.y += this.vy * deltaTime;
            }
        }
    }, {
        key: 'hasCollided',
        value: function hasCollided(otherBorder) {
            var myBorder = this.border;

            return Math.min(myBorder.right, otherBorder.right) - Math.max(myBorder.left, otherBorder.left) >= 0 && Math.min(myBorder.bottom, otherBorder.bottom) - Math.max(myBorder.top, otherBorder.top) >= 0;
        }
    }, {
        key: 'borderWidth',
        get: function get() {
            return this.originalBorderWidth * this.scaleX;
        }
    }, {
        key: 'borderHeight',
        get: function get() {
            return this.originalBorderHeight * this.scaleY;
        }
    }, {
        key: 'originalBorder',
        get: function get() {
            return [this.originalBorderWidth, this.originalBorderHeight];
        },
        set: function set(originalBorder) {
            if (originalBorder instanceof Array && originalBorder.length == 2 && typeof originalBorder[0] == 'number' && typeof originalBorder[1] == 'number') {
                this.originalBorderWidth = originalBorder[0];
                this.originalBorderHeight = originalBorder[1];
            } else {
                console.error('set ImageObject.originalBorder: originalBorder is not an array of size 2 that contains numbers.');
            }
        }
    }, {
        key: 'border',
        get: function get() {
            var borderRadius = [+0.5 * this.originalBorderWidth * this.scaleX, 0.5 * this.originalBorderHeight * this.scaleY];

            return {
                top: this.y + borderRadius[1],
                right: this.x + borderRadius[0],
                bottom: this.y - borderRadius[1],
                left: this.x - borderRadius[0]
            };
        }
    }]);

    return GameObject;
}(ImageObject);
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Render = function () {
    function Render(canvas) {
        _classCallCheck(this, Render);

        if (Render.instance instanceof Render) {
            console.error('Render.constructor: Render instance already exists.');
            return null;
        }

        if (!(canvas instanceof HTMLCanvasElement)) {
            console.error("Render.constructor: given canvas object is not an HTMLCanvasElement.");
            return null;
        }

        Render.instance = this;

        this.canvas = canvas;
        this.context2D = this.canvas.getContext('2d');

        this.updateCanvasSize();

        window.addEventListener('resize', this.updateCanvasSize);

        // Coordinate sytem. Axis orientation will be: X->right , Y->up
        this.originX = 0.5;
        this.originY = 0.5;

        this.coordOffsetX = 0;
        this.coordOffsetY = 0;

        this.objectSet = new Set();

        this.drawTileGrid = false;
        this.drawBorders = false;
        this.drawTileHighlight = false;
    }

    _createClass(Render, [{
        key: 'canvasPositionToRenderCoordinates',
        value: function canvasPositionToRenderCoordinates(position) {
            if (position instanceof Array && position.length == 2 && typeof position[0] == 'number' && typeof position[1] == 'number') {
                var realOrigin = this.realOrigin;

                return [position[0] - realOrigin[0], realOrigin[1] - position[1]];
            } else {
                console.error('set Render.canvasPositionToRenderCoordinates: position is not an array of size 2 that contains numbers.');
                return null;
            }
        }
    }, {
        key: 'mousePositionToCanvasRelativePosition',
        value: function mousePositionToCanvasRelativePosition(mousePosition) {
            var canvasRect = this.canvas.getBoundingClientRect();

            return [mousePosition[0] - canvasRect.left, mousePosition[1] - canvasRect.top];
        }
    }, {
        key: 'mousePositionToRenderCoordinates',
        value: function mousePositionToRenderCoordinates(mousePosition) {
            return this.canvasPositionToRenderCoordinates(this.mousePositionToCanvasRelativePosition(mousePosition));
        }
    }, {
        key: 'mousePositionToTileCoordinates',
        value: function mousePositionToTileCoordinates(mousePosition) {
            if (!Terrain) {
                console.error('Render.mousePositionToTileCoordinates: Terrain class is not defined.');
            } else if (!(this.terrain instanceof Terrain)) {
                console.error('Render.mousePositionToTileCoordinates: terrain is not set.');
            } else {
                var realOrigin = this.realOrigin;
                var relativeCanvasPosition = this.mousePositionToCanvasRelativePosition(mousePosition);

                var coordinates = [0.5 + (relativeCanvasPosition[0] - realOrigin[0]) / this.terrain.tileSizeX, -0.5 + (realOrigin[1] - relativeCanvasPosition[1]) / this.terrain.tileSizeY];

                return [Math.floor(coordinates[0]), Math.ceil(coordinates[1])];
            }
        }
    }, {
        key: 'updateCanvasSize',
        value: function updateCanvasSize() {
            var containerStyle = window.getComputedStyle(this.canvas.parentElement);

            this.canvas.width = parseFloat(containerStyle.width) - parseFloat(containerStyle.paddingLeft) - parseFloat(containerStyle.paddingRight) - parseFloat(containerStyle.borderLeftWidth) - parseFloat(containerStyle.borderRightWidth);
            this.canvas.height = parseFloat(containerStyle.height) - parseFloat(containerStyle.paddingTop) - parseFloat(containerStyle.paddingBottom) - parseFloat(containerStyle.borderTopWidth) - parseFloat(containerStyle.borderBottomWidth);
        }
    }, {
        key: 'registerObject',
        value: function registerObject(imageObject) {
            if (!ImageObject) {
                console.error('Render.registerObject: ImageObject class is not defined.');
            } else if (!(imageObject instanceof ImageObject)) {
                console.error('Render.registerObject: imageObject is not a ImageObject object.');
            } else {
                this.objectSet.add(imageObject);
            }
        }
    }, {
        key: 'setTerrain',
        value: function setTerrain(terrain) {
            if (!Terrain) {
                console.error('Render.setTerrain: Terrain class is not defined.');
            } else if (!(terrain instanceof Terrain)) {
                console.error('Render.setTerrain: terrain is not a Terrain object.');
            } else {
                this.terrain = terrain;
            }
        }
    }, {
        key: 'render',
        value: function render() {
            this.context2D.clearRect(0, 0, this.canvas.width, this.canvas.height);

            this.renderTerrain();

            if (this.drawTileGrid) {
                this.renderTileGrid();
            }

            this.renderObjects();
        }
    }, {
        key: 'renderTerrain',
        value: function renderTerrain() {
            var realOrigin = this.realOrigin;

            this.context2D.fillStyle = 'rgba(255, 255, 255, 0.4)';

            if (this.terrain) {
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = this.terrain.tiles[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var tile = _step.value;

                        var tilePosition = [(realOrigin[0] + (tile.row - 0.5) * this.terrain.tileSizeX).toFixed(), (realOrigin[1] - (tile.column + 0.5) * this.terrain.tileSizeY).toFixed()];

                        if (tile.sprite) {
                            this.context2D.drawImage(tile.sprite, tilePosition[0], tilePosition[1], this.terrain.tileSizeX.toFixed(), this.terrain.tileSizeY.toFixed());
                        }

                        if (this.drawTileHighlight && tile.highlighted) {
                            this.context2D.fillRect(tilePosition[0], tilePosition[1], this.terrain.tileSizeX.toFixed(), this.terrain.tileSizeY.toFixed());
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return) {
                            _iterator.return();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }
        }
    }, {
        key: 'renderObjects',
        value: function renderObjects() {
            var realOrigin = this.realOrigin;

            var objectSize = void 0,
                objectBorder = void 0;

            this.context2D.strokeStyle = 'purple';
            this.context2D.lineWidth = 2;

            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
                for (var _iterator2 = _.sortBy([].concat(_toConsumableArray(this.objectSet)), 'layer')[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                    var objectToRender = _step2.value;

                    objectSize = objectToRender.size;
                    this.context2D.drawImage(objectToRender.sprite, (realOrigin[0] + objectToRender.x - objectToRender.pivotX * objectSize[0]).toFixed(), (realOrigin[1] - (objectToRender.y + (1 - objectToRender.pivotY) * objectSize[1])).toFixed(), objectSize[0].toFixed(), objectSize[1].toFixed());

                    if (this.drawBorders) {
                        if (!GameObject) {
                            console.error('Render.renderObjects: GameObject class not defined.');
                        } else if (objectToRender instanceof GameObject) {
                            objectBorder = objectToRender.border;
                            this.context2D.strokeRect(realOrigin[0] + objectBorder.left, realOrigin[1] - objectBorder.top, objectToRender.borderWidth, objectToRender.borderHeight);
                        }
                    }
                }
            } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion2 && _iterator2.return) {
                        _iterator2.return();
                    }
                } finally {
                    if (_didIteratorError2) {
                        throw _iteratorError2;
                    }
                }
            }
        }
    }, {
        key: 'renderTileGrid',
        value: function renderTileGrid() {
            if (this.terrain) {
                this.context2D.strokeStyle = 'white';
                this.context2D.lineWidth = 1;

                var realOrigin = this.realOrigin;

                var minX = Math.ceil(0.5 - realOrigin[0] / this.terrain.tileSizeX);
                var maxX = Math.floor(0.5 + (this.canvas.width - realOrigin[0]) / this.terrain.tileSizeX);

                var minY = Math.ceil(-0.5 + (realOrigin[1] - this.canvas.height) / this.terrain.tileSizeY);
                var maxY = Math.floor(-0.5 + realOrigin[1] / this.terrain.tileSizeY);

                this.context2D.beginPath();

                var loackedPosition = 0;

                for (var i = minX; i <= maxX; i++) {
                    loackedPosition = (realOrigin[0] + (i - 0.5) * this.terrain.tileSizeX).toFixed();
                    this.context2D.moveTo(loackedPosition, 0);
                    this.context2D.lineTo(loackedPosition, this.canvas.height);
                }

                for (var j = minY; j <= maxY; j++) {
                    loackedPosition = (realOrigin[1] - (j + 0.5) * this.terrain.tileSizeY).toFixed();
                    this.context2D.moveTo(0, loackedPosition);
                    this.context2D.lineTo(this.canvas.width, loackedPosition);
                }

                this.context2D.stroke();
            }
        }
    }, {
        key: 'origin',
        get: function get() {
            return [this.originX, this.originY];
        },
        set: function set(origin) {
            if (origin instanceof Array && origin.length == 2 && typeof origin[0] == 'number' && typeof origin[1] == 'number') {
                this.originX = origin[0];
                this.originY = origin[1];
            } else {
                console.error('set Render.origin: origin is not an array of size 2 that contains numbers.');
            }
        }
    }, {
        key: 'coordOffset',
        get: function get() {
            return [this.coordOffsetX, this.coordOffsetY];
        },
        set: function set(coordOffset) {
            if (coordOffset instanceof Array && coordOffset.length == 2 && typeof coordOffset[0] == 'number' && typeof coordOffset[1] == 'number') {
                this.coordOffsetX = coordOffset[0].toFixed();
                this.coordOffsetY = coordOffset[1].toFixed();
            } else {
                console.error('set Render.coordOffset: coordOffset is not an array of size 2 that contains numbers.');
            }
        }
    }, {
        key: 'realOrigin',
        get: function get() {
            return [this.originX * this.canvas.width + this.coordOffsetX, (1 - this.originY) * this.canvas.height - this.coordOffsetY];
        }
    }]);

    return Render;
}();
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ImageResourceStatus = {
    INITIATING: 'Initiating',
    FAILED: 'Failed',
    LOADING: 'Loading',
    LOADED: 'Loaded'
};

var ImageResource = function () {
    function ImageResource() {
        _classCallCheck(this, ImageResource);

        this.progress = 0;
        this.status = ImageResourceStatus.INITIATING;
        this.onLoad = null;
        this.onProgress = null;
        this.onStatusChanged = null;
    }

    _createClass(ImageResource, [{
        key: 'setProgress',
        value: function setProgress(progress) {
            this.progress = progress;

            console.log('ImageResource.setProgress: ' + progress);

            if (this.onProgress) {
                this.onProgress(this.progress);
            }
        }
    }, {
        key: 'setStatus',
        value: function setStatus(status) {
            this.status = status;

            if (this.onStatusChanged) {
                this.onStatusChanged(this.status);
            }

            switch (this.status) {
                case ImageResourceStatus.INITIATING:
                    break;

                case ImageResourceStatus.FAILED:
                    break;

                case ImageResourceStatus.LOADING:
                    break;

                case ImageResourceStatus.LOADED:
                    this.setProgress(1);
                    if (this.onLoad) {
                        this.onLoad();
                    }
                    break;

                default:
            }
        }
    }, {
        key: 'setTriggers',
        value: function setTriggers() {
            var _this = this;

            if (this.img) {
                this.promise = new Promise(function (resolve, reject) {
                    _this.img.onloadstart = function () {
                        _this.setStatus(ImageResourceStatus.LOADING);
                    };
                    _this.img.onprogress = function (progress) {
                        _this.progress = _this.setProgress(progress);
                    };
                    _this.img.onload = function () {
                        _this.setStatus(ImageResourceStatus.LOADED);
                        resolve(_this);
                    };
                    _this.img.onerror = function (error) {
                        _this.setStatus(ImageResourceStatus.FAILED);
                        reject(error);
                    };
                });
            }
        }
    }, {
        key: 'setSource',
        value: function setSource(source) {
            if (source) {
                if (source instanceof Image) {
                    if (source.src) {
                        this.imageSrc = source.src;
                        this.img = source;

                        if (source.completed) {
                            this.setStatus(ImageResourceStatus.LOADED);
                        } else {
                            this.setTriggers();
                        }
                    } else {
                        console.error('ImageResource requires a proper source.');
                    }
                } else if (typeof source == 'string') {
                    this.imageSrc = source;
                    this.img = new Image();

                    this.setTriggers();

                    this.img.src = source;
                }

                return this.promise;
            } else {
                console.error('ImageResource requires a proper source.');
            }
        }
    }, {
        key: 'loaded',
        get: function get() {
            return this.status == ImageResourceStatus.LOADED;
        }
    }], [{
        key: 'IMAGE_STATUS',
        get: function get() {
            return ImageResourceStatus;
        }
    }]);

    return ImageResource;
}();

var Resources = function () {
    function Resources() {
        _classCallCheck(this, Resources);

        this.imageCache = new Map();
    }

    /**
    * @method addImage - Add an image resource and starts loading it if possible.
    * @param {Object|string} imgSource - image source. It may be an img element object or the img url string.
    * @param {string} [alias] - image alias used to retrieve resource. if imgSource is a string and alias is not specified, then the alias will be set to the imgSource.
    * @return {Promisse} - promise that fullfills when the resource has loaded.
    */


    _createClass(Resources, [{
        key: 'addImage',
        value: function addImage(imgSource, alias) {
            if (typeof imgSource == 'string' && !alias) {
                alias = imgSource;
            }

            var newImageResource = new ImageResource();

            if (!alias) {
                console.log('Resources.addImage: alias not set and thus this image will not be cached!');
            } else {
                if (this.imageCache.has(alias)) {
                    window.alert('Resources.addImage: image alias "' + alias + '" is already being used and will be overwritten.');
                }

                this.imageCache.set(alias, newImageResource);
            }

            return newImageResource.setSource(imgSource);
        }

        /**
        * @method addImages - Same as addImage but for multple image resources.
        * @param {Array} sources - each element should be an array that matches the arguments of the addImage method: [imgSource, alias].
        * @return {Promisse} - promise that fullfills when all resources have loaded.
        */

    }, {
        key: 'addImages',
        value: function addImages(sources) {
            if (!(sources instanceof Array)) {
                console.error('Resources.addImages: argument is not an array');

                return;
            }

            var promises = [];

            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = sources[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var aguments = _step.value;

                    if (arguments instanceof Array) {
                        promises.push(this.addImage.apply(this, aguments));
                    } else {
                        promises.push(this.addImage(aguments));
                    }
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator.return) {
                        _iterator.return();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }

            return Promise.all(promises);
        }

        /**
        * @method getImage - returns the img element object respective to the given alias.
        */

    }, {
        key: 'getImage',
        value: function getImage(alias) {
            var cache = this.imageCache.get(alias);

            if (!cache) {
                console.error('Resources.getImage: could not find alias "${alias}"');
            }

            return cache;
        }
    }]);

    return Resources;
}();
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Tile = function Tile(row, column, sprite) {
    _classCallCheck(this, Tile);

    if (sprite instanceof Image) {
        this.sprite = sprite;
    } else if (sprite) {
        console.error('Tile.constructor: sprite is not a Image object.');
        return null;
    }

    row = Number(row.toFixed());
    column = Number(column.toFixed());

    if (typeof row == 'number' && typeof column == 'number') {
        this.row = row;
        this.column = column;
    } else {
        console.error('Tile.constructor: row and column must be numbers.');
        return null;
    }

    this.highlighted = false;
};

var Terrain = function () {
    function Terrain() {
        _classCallCheck(this, Terrain);

        this.tileSizeX = 64;
        this.tileSizeY = 64;

        this.tileMap = new Map();
        this.tileHighlightMap = new Map();
    }

    _createClass(Terrain, [{
        key: 'setTile',
        value: function setTile(tile) {
            if (!(tile instanceof Tile)) {
                console.error('Terrain.setTile: tile is not a Tile object.');
            } else {
                this.tileMap.set(tile.row + 'x' + tile.column, tile);
            }
        }
    }, {
        key: 'setTiles',
        value: function setTiles(tiles) {
            if (!(tiles instanceof Array)) {
                console.error('Terrain.setTiles: tiles is not an Array.');
            } else {
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = tiles[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var tile = _step.value;

                        this.setTile(tile);
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return) {
                            _iterator.return();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }
        }
    }, {
        key: 'setTileHighlight',
        value: function setTileHighlight(row, column) {
            var highlighted = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

            if (typeof row == 'number' && typeof column == 'number' && typeof highlighted == 'boolean') {
                var tile = this.tileMap.get(row + 'x' + column);
                if (!tile) {
                    tile = new Tile(row, column);
                    this.setTile(tile);
                }

                tile.highlighted = highlighted;

                return tile;
            } else {
                console.error('Terrain.setTileHighlight: row and column must be numbers and highlighted must be a boolean.');
            }

            return null;
        }
    }, {
        key: 'tiles',
        get: function get() {
            return [].concat(_toConsumableArray(this.tileMap.values()));
        }
    }, {
        key: 'tileSize',
        get: function get() {
            return [this.tileSizeX, this.tileSizeY];
        },
        set: function set(tileSize) {
            if (tileSize instanceof Array && tileSize.length == 2 && typeof tileSize[0] == 'number' && typeof tileSize[1] == 'number') {
                this.tileSizeX = tileSize[0];
                this.tileSizeY = tileSize[1];
            } else {
                console.error('set Terrain.tileSize: tileSize is not an array of size 2 that contains numbers.');
            }
        }
    }]);

    return Terrain;
}();
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImVuZ2luZS5qcyIsImZsYXQuanMiLCJnYW1lLW9iamVjdC5qcyIsInJlbmRlci5qcyIsInJlc291cmNlcy5qcyIsInRlcnJhaW4uanMiXSwibmFtZXMiOlsiRW5naW5lIiwiaW5zdGFuY2UiLCJjb25zb2xlIiwiZXJyb3IiLCJsYXN0VGltZSIsIkRhdGUiLCJub3ciLCJjYWxsYmFja1NldCIsIlNldCIsImtleUNhbGxiYWNrU2V0IiwibW91c2VDYWxsYmFja1NldCIsImRvY3VtZW50IiwiYWRkRXZlbnRMaXN0ZW5lciIsImhhbmRsZUtleUV2ZW50cyIsImJpbmQiLCJSZW5kZXIiLCJyZW5kZXIiLCJjYW52YXMiLCJoYW5kbGVNb3VzZUV2ZW50cyIsImV2ZW50IiwiY2FsbGJhY2siLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJyb3V0aW5lIiwiZGVsdGFUaW1lIiwiY3VycmVudFRpbWUiLCJhZGQiLCJmbGF0IiwiSW1hZ2VPYmplY3QiLCJzcHJpdGUiLCJzdWJzY3JpYmVUb1JlbmRlciIsIkltYWdlIiwib3JpZ2luYWxzaXplWCIsIndpZHRoIiwib3JpZ2luYWxzaXplWSIsImhlaWdodCIsInBpdm90WCIsInBpdm90WSIsIngiLCJ5Iiwic2NhbGVYIiwic2NhbGVZIiwibGF5ZXIiLCJyZWdpc3Rlck9iamVjdCIsInBpdm90IiwiQXJyYXkiLCJsZW5ndGgiLCJwb3NpdGlvbiIsIm9yaWdpbmFsc2l6ZSIsInNjYWxlIiwiR2FtZU9iamVjdCIsInZ4IiwidnkiLCJvcmlnaW5hbEJvcmRlcldpZHRoIiwib3JpZ2luYWxCb3JkZXJIZWlnaHQiLCJhY3RpdmUiLCJvdGhlckJvcmRlciIsIm15Qm9yZGVyIiwiYm9yZGVyIiwiTWF0aCIsIm1pbiIsInJpZ2h0IiwibWF4IiwibGVmdCIsImJvdHRvbSIsInRvcCIsIm9yaWdpbmFsQm9yZGVyIiwiYm9yZGVyUmFkaXVzIiwiSFRNTENhbnZhc0VsZW1lbnQiLCJjb250ZXh0MkQiLCJnZXRDb250ZXh0IiwidXBkYXRlQ2FudmFzU2l6ZSIsIndpbmRvdyIsIm9yaWdpblgiLCJvcmlnaW5ZIiwiY29vcmRPZmZzZXRYIiwiY29vcmRPZmZzZXRZIiwib2JqZWN0U2V0IiwiZHJhd1RpbGVHcmlkIiwiZHJhd0JvcmRlcnMiLCJkcmF3VGlsZUhpZ2hsaWdodCIsInJlYWxPcmlnaW4iLCJtb3VzZVBvc2l0aW9uIiwiY2FudmFzUmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImNhbnZhc1Bvc2l0aW9uVG9SZW5kZXJDb29yZGluYXRlcyIsIm1vdXNlUG9zaXRpb25Ub0NhbnZhc1JlbGF0aXZlUG9zaXRpb24iLCJUZXJyYWluIiwidGVycmFpbiIsInJlbGF0aXZlQ2FudmFzUG9zaXRpb24iLCJjb29yZGluYXRlcyIsInRpbGVTaXplWCIsInRpbGVTaXplWSIsImZsb29yIiwiY2VpbCIsImNvbnRhaW5lclN0eWxlIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsInBhcmVudEVsZW1lbnQiLCJwYXJzZUZsb2F0IiwicGFkZGluZ0xlZnQiLCJwYWRkaW5nUmlnaHQiLCJib3JkZXJMZWZ0V2lkdGgiLCJib3JkZXJSaWdodFdpZHRoIiwicGFkZGluZ1RvcCIsInBhZGRpbmdCb3R0b20iLCJib3JkZXJUb3BXaWR0aCIsImJvcmRlckJvdHRvbVdpZHRoIiwiaW1hZ2VPYmplY3QiLCJjbGVhclJlY3QiLCJyZW5kZXJUZXJyYWluIiwicmVuZGVyVGlsZUdyaWQiLCJyZW5kZXJPYmplY3RzIiwiZmlsbFN0eWxlIiwidGlsZXMiLCJ0aWxlIiwidGlsZVBvc2l0aW9uIiwicm93IiwidG9GaXhlZCIsImNvbHVtbiIsImRyYXdJbWFnZSIsImhpZ2hsaWdodGVkIiwiZmlsbFJlY3QiLCJvYmplY3RTaXplIiwib2JqZWN0Qm9yZGVyIiwic3Ryb2tlU3R5bGUiLCJsaW5lV2lkdGgiLCJfIiwic29ydEJ5Iiwib2JqZWN0VG9SZW5kZXIiLCJzaXplIiwic3Ryb2tlUmVjdCIsImJvcmRlcldpZHRoIiwiYm9yZGVySGVpZ2h0IiwibWluWCIsIm1heFgiLCJtaW5ZIiwibWF4WSIsImJlZ2luUGF0aCIsImxvYWNrZWRQb3NpdGlvbiIsImkiLCJtb3ZlVG8iLCJsaW5lVG8iLCJqIiwic3Ryb2tlIiwib3JpZ2luIiwiY29vcmRPZmZzZXQiLCJJbWFnZVJlc291cmNlU3RhdHVzIiwiSU5JVElBVElORyIsIkZBSUxFRCIsIkxPQURJTkciLCJMT0FERUQiLCJJbWFnZVJlc291cmNlIiwicHJvZ3Jlc3MiLCJzdGF0dXMiLCJvbkxvYWQiLCJvblByb2dyZXNzIiwib25TdGF0dXNDaGFuZ2VkIiwibG9nIiwic2V0UHJvZ3Jlc3MiLCJpbWciLCJwcm9taXNlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJvbmxvYWRzdGFydCIsInNldFN0YXR1cyIsIm9ucHJvZ3Jlc3MiLCJvbmxvYWQiLCJvbmVycm9yIiwic291cmNlIiwic3JjIiwiaW1hZ2VTcmMiLCJjb21wbGV0ZWQiLCJzZXRUcmlnZ2VycyIsIlJlc291cmNlcyIsImltYWdlQ2FjaGUiLCJNYXAiLCJpbWdTb3VyY2UiLCJhbGlhcyIsIm5ld0ltYWdlUmVzb3VyY2UiLCJoYXMiLCJhbGVydCIsInNldCIsInNldFNvdXJjZSIsInNvdXJjZXMiLCJwcm9taXNlcyIsImFndW1lbnRzIiwiYXJndW1lbnRzIiwicHVzaCIsImFkZEltYWdlIiwiYXBwbHkiLCJhbGwiLCJjYWNoZSIsImdldCIsIlRpbGUiLCJOdW1iZXIiLCJ0aWxlTWFwIiwidGlsZUhpZ2hsaWdodE1hcCIsInNldFRpbGUiLCJ2YWx1ZXMiLCJ0aWxlU2l6ZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7OztJQUdNQTtBQUNGOzs7QUFHQSxzQkFBYztBQUFBOztBQUNWLFlBQUdBLE9BQU9DLFFBQVAsWUFBMkJELE1BQTlCLEVBQXNDO0FBQ2xDRSxvQkFBUUMsS0FBUixDQUFjLHFEQUFkO0FBQ0EsbUJBQU8sSUFBUDtBQUNIOztBQUVESCxlQUFPQyxRQUFQLEdBQWtCLElBQWxCOztBQUVBLGFBQUtHLFFBQUwsR0FBZ0JDLEtBQUtDLEdBQUwsRUFBaEI7QUFDQSxh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QUFYO0FBQ0g7Ozs0QkFFYztBQUNYLG1CQUFPLENBQUMsS0FBSzVHLFNBQU4sRUFBaUIsS0FBS0MsU0FBdEIsQ0FBUDtBQUNIOzBCQUVZNEcsVUFBVTtBQUNuQixnQkFBS0Esb0JBQW9CM0osS0FBckIsSUFBZ0MySixTQUFTMUosTUFBVCxJQUFtQixDQUFuRCxJQUEwRCxPQUFPMEosU0FBUyxDQUFULENBQVAsSUFBc0IsUUFBaEYsSUFBOEYsT0FBT0EsU0FBUyxDQUFULENBQVAsSUFBc0IsUUFBeEgsRUFBb0k7QUFDaEkscUJBQUs3RyxTQUFMLEdBQWlCNkcsU0FBUyxDQUFULENBQWpCO0FBQ0EscUJBQUs1RyxTQUFMLEdBQWlCNEcsU0FBUyxDQUFULENBQWpCO0FBQ0gsYUFIRCxNQUlLO0FBQ0RyTSx3QkFBUUMsS0FBUixDQUFjLGlGQUFkO0FBQ0g7QUFDSiIsImZpbGUiOiJmbGF0LWVuZ2luZS5taW4uanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuKiBAY2xhc3NcclxuKi9cclxuY2xhc3MgRW5naW5lIHtcclxuICAgIC8qKlxyXG4gICAgKiBAY29uc3RydWN0b3JcclxuICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBpZihFbmdpbmUuaW5zdGFuY2UgaW5zdGFuY2VvZiBFbmdpbmUpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRW5naW5lLmNvbnN0cnVjdG9yOiBFbmdpbmUgaW5zdGFuY2UgYWxyZWFkeSBleGlzdHMuJyk7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgRW5naW5lLmluc3RhbmNlID0gdGhpcztcclxuXHJcbiAgICAgICAgdGhpcy5sYXN0VGltZSA9IERhdGUubm93KCk7XHJcbiAgICAgICAgdGhpcy5jYWxsYmFja1NldCA9IG5ldyBTZXQoKTtcclxuICAgICAgICB0aGlzLmtleUNhbGxiYWNrU2V0ID0gbmV3IFNldCgpO1xyXG4gICAgICAgIHRoaXMubW91c2VDYWxsYmFja1NldCA9IG5ldyBTZXQoKTtcclxuXHJcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB0aGlzLmhhbmRsZUtleUV2ZW50cy5iaW5kKHRoaXMpKTtcclxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5oYW5kbGVLZXlFdmVudHMuYmluZCh0aGlzKSk7XHJcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5cHJlc3MnLCB0aGlzLmhhbmRsZUtleUV2ZW50cy5iaW5kKHRoaXMpKTtcclxuXHJcbiAgICAgICAgaWYoIVJlbmRlcikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFbmdpbmUuY29uc3RydWN0b3I6IFJlbmRlciBjbGFzcyBpcyBub3QgZGVmaW5lZC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZighKFJlbmRlci5pbnN0YW5jZSBpbnN0YW5jZW9mIFJlbmRlcikpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRW5naW5lLmNvbnN0cnVjdG9yOiBUaGVyZSBpcyBubyByZW5kZXIgaW5zdGFuY2UgdG8gc3Vic2NyaWJyZSBtb3VzZSBldmVudHMuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlciA9IFJlbmRlci5pbnN0YW5jZTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW92ZXInLCB0aGlzLmhhbmRsZU1vdXNlRXZlbnRzLmJpbmQodGhpcykpO1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlci5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5oYW5kbGVNb3VzZUV2ZW50cy5iaW5kKHRoaXMpKTtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXIuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCB0aGlzLmhhbmRsZU1vdXNlRXZlbnRzLmJpbmQodGhpcykpO1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlci5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdXQnLCB0aGlzLmhhbmRsZU1vdXNlRXZlbnRzLmJpbmQodGhpcykpO1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlci5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmhhbmRsZU1vdXNlRXZlbnRzLmJpbmQodGhpcykpO1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlci5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignYXV4Y2xpY2snLCB0aGlzLmhhbmRsZU1vdXNlRXZlbnRzLmJpbmQodGhpcykpO1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlci5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5oYW5kbGVNb3VzZUV2ZW50cy5iaW5kKHRoaXMpKTtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXIuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLmhhbmRsZU1vdXNlRXZlbnRzLmJpbmQodGhpcykpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBoYW5kbGVLZXlFdmVudHMoZXZlbnQpIHtcclxuICAgICAgICBmb3IoY29uc3QgY2FsbGJhY2sgb2YgdGhpcy5rZXlDYWxsYmFja1NldCkge1xyXG4gICAgICAgICAgICBjYWxsYmFjayhldmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGhhbmRsZU1vdXNlRXZlbnRzKGV2ZW50KSB7XHJcbiAgICAgICAgZm9yKGNvbnN0IGNhbGxiYWNrIG9mIHRoaXMubW91c2VDYWxsYmFja1NldCkge1xyXG4gICAgICAgICAgICBjYWxsYmFjayhldmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHN0YXJ0KCkge1xyXG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLnJvdXRpbmUuYmluZCh0aGlzKSk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IGN1cnJlbnRUaW1lKCkge1xyXG4gICAgICAgIHJldHVybiBEYXRlLm5vdygpO1xyXG4gICAgfVxyXG5cclxuICAgIHJvdXRpbmUoKSB7XHJcbiAgICAgICAgY29uc3QgZGVsdGFUaW1lID0gdGhpcy5jdXJyZW50VGltZSAtIHRoaXMubGFzdFRpbWU7XHJcblxyXG4gICAgICAgIGZvcihjb25zdCBjYWxsYmFjayBvZiB0aGlzLmNhbGxiYWNrU2V0KSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKGRlbHRhVGltZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnJlbmRlci5yZW5kZXIoKTtcclxuXHJcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMucm91dGluZS5iaW5kKHRoaXMpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICogQGNhbGxiYWNrIHJvdXRpbmVDYWxsYmFja1xyXG4gICAgKiBAcGFyYW0ge251bWJlcn0gZGVsdGFUaW1lIC0gdGltZSBzaW5jZSB0aGUgY2FsbGJhY2sgd2FzIGxhc3QgY2FsbGVkLlxyXG4gICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICogQG1ldGhvZCByZWdpc3RlclJvdXRpbmVDYWxsYmFjayAtIGFkZCBhIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgYnkgdGhlIGVuZ2luZS5cclxuICAgICogQHBhcmFtIHtyb3V0aW5lQ2FsbGJhY2t9IGNhbGxiYWNrXHJcbiAgICAqL1xyXG4gICAgcmVnaXN0ZXJSb3V0aW5lQ2FsbGJhY2soY2FsbGJhY2spIHtcclxuICAgICAgICBpZih0eXBlb2YgY2FsbGJhY2sgPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrU2V0LmFkZChjYWxsYmFjayk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFbmdpbmUucmVnaXN0ZXJSb3V0aW5lQ2FsbGJhY2s6IGNhbGxiYWNrIGlzIG5vdCBzZXQgYXMgYSBmdW5jdGlvbi4nKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmVnaXN0ZXJLZXlFdmVudENhbGxiYWNrKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgaWYodHlwZW9mIGNhbGxiYWNrID09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgdGhpcy5rZXlDYWxsYmFja1NldC5hZGQoY2FsbGJhY2spO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRW5naW5lLnJlZ2lzdGVyS2V5RXZlbnRDYWxsYmFjazogY2FsbGJhY2sgaXMgbm90IHNldCBhcyBhIGZ1bmN0aW9uLicpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZWdpc3Rlck1vdXNlRXZlbnRDYWxsYmFjayhjYWxsYmFjaykge1xyXG4gICAgICAgIGlmKHR5cGVvZiBjYWxsYmFjayA9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHRoaXMubW91c2VDYWxsYmFja1NldC5hZGQoY2FsbGJhY2spO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRW5naW5lLnJlZ2lzdGVyTW91c2VFdmVudENhbGxiYWNrOiBjYWxsYmFjayBpcyBub3Qgc2V0IGFzIGEgZnVuY3Rpb24uJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbiIsImNvbnN0IGZsYXQgPSB7fTtcclxuIiwiLyoqXHJcbiogQGNsYXNzXHJcbiovXHJcbmNsYXNzIEltYWdlT2JqZWN0IHtcclxuICAgIC8qKlxyXG4gICAgKiBAY29uc3RydWN0b3JcclxuICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihzcHJpdGUsIHN1YnNjcmliZVRvUmVuZGVyID0gdHJ1ZSkge1xyXG4gICAgICAgIGlmKHNwcml0ZSBpbnN0YW5jZW9mIEltYWdlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlID0gc3ByaXRlO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5vcmlnaW5hbHNpemVYID0gc3ByaXRlLndpZHRoO1xyXG4gICAgICAgICAgICB0aGlzLm9yaWdpbmFsc2l6ZVkgPSBzcHJpdGUuaGVpZ2h0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmKHNwcml0ZSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdHYW1lT2JqZWN0LmNvbnN0cnVjdG9yOiBzcHJpdGUgaXMgbm90IHNldCBhcyBhIEltYWdlIG9iamVjdC4nKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMucGl2b3RYID0gMC41O1xyXG4gICAgICAgIHRoaXMucGl2b3RZID0gMC41O1xyXG5cclxuICAgICAgICB0aGlzLnggPSAwO1xyXG4gICAgICAgIHRoaXMueSA9IDA7XHJcblxyXG4gICAgICAgIHRoaXMub3JpZ2luYWxzaXplWCA9IHRoaXMub3JpZ2luYWxzaXplWCB8fCAwO1xyXG4gICAgICAgIHRoaXMub3JpZ2luYWxzaXplWSA9IHRoaXMub3JpZ2luYWxzaXplWSB8fCAwO1xyXG5cclxuICAgICAgICB0aGlzLnNjYWxlWCA9IDE7XHJcbiAgICAgICAgdGhpcy5zY2FsZVkgPSAxO1xyXG5cclxuICAgICAgICB0aGlzLmxheWVyID0gMDtcclxuXHJcbiAgICAgICAgaWYoc3Vic2NyaWJlVG9SZW5kZXIpIHtcclxuICAgICAgICAgICAgaWYoIVJlbmRlcikge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignSW1hZ2VPYmplY3QuY29uc3RydWN0b3I6IFJlbmRlciBjbGFzcyBpcyBub3QgZGVmaW5lZC4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmKCEoUmVuZGVyLmluc3RhbmNlIGluc3RhbmNlb2YgUmVuZGVyKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignSW1hZ2VPYmplY3QuY29uc3RydWN0b3I6IFRoZXJlIGlzIG5vIHJlbmRlciBpbnN0YW5jZSB0byBzdWJzY3JpYnJlIHRvLicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgUmVuZGVyLmluc3RhbmNlLnJlZ2lzdGVyT2JqZWN0KHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGdldCBwaXZvdCgpIHtcclxuICAgICAgICByZXR1cm4gW3RoaXMucGl2b3RYLCB0aGlzLnBpdm90WV07XHJcbiAgICB9XHJcblxyXG4gICAgc2V0IHBpdm90KHBpdm90KSB7XHJcbiAgICAgICAgaWYoIChwaXZvdCBpbnN0YW5jZW9mIEFycmF5KSAmJiAocGl2b3QubGVuZ3RoID09IDIpICYmICh0eXBlb2YgcGl2b3RbMF0gPT0gJ251bWJlcicpICYmICh0eXBlb2YgcGl2b3RbMV0gPT0gJ251bWJlcicpICkge1xyXG4gICAgICAgICAgICB0aGlzLnBpdm90WCA9IHBpdm90WzBdO1xyXG4gICAgICAgICAgICB0aGlzLnBpdm90WSA9IHBpdm90WzFdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcignc2V0IEltYWdlT2JqZWN0LnBpdm90OiBwaXZvdCBpcyBub3QgYW4gYXJyYXkgb2Ygc2l6ZSAyIHRoYXQgY29udGFpbnMgbnVtYmVycy4nKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IHBvc2l0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBbdGhpcy54LCB0aGlzLnldO1xyXG4gICAgfVxyXG5cclxuICAgIHNldCBwb3NpdGlvbihwb3NpdGlvbikge1xyXG4gICAgICAgIGlmKCAocG9zaXRpb24gaW5zdGFuY2VvZiBBcnJheSkgJiYgKHBvc2l0aW9uLmxlbmd0aCA9PSAyKSAmJiAodHlwZW9mIHBvc2l0aW9uWzBdID09ICdudW1iZXInKSAmJiAodHlwZW9mIHBvc2l0aW9uWzFdID09ICdudW1iZXInKSApIHtcclxuICAgICAgICAgICAgdGhpcy54ID0gcG9zaXRpb25bMF07XHJcbiAgICAgICAgICAgIHRoaXMueSA9IHBvc2l0aW9uWzFdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcignc2V0IEltYWdlT2JqZWN0LnBvc2l0aW9uOiBwb3NpdGlvbiBpcyBub3QgYW4gYXJyYXkgb2Ygc2l6ZSAyIHRoYXQgY29udGFpbnMgbnVtYmVycy4nKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IHNpemVYKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm9yaWdpbmFsc2l6ZVgqdGhpcy5zY2FsZVg7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IHNpemVZKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm9yaWdpbmFsc2l6ZVkqdGhpcy5zY2FsZVk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IHNpemUoKSB7XHJcbiAgICAgICAgcmV0dXJuIFt0aGlzLm9yaWdpbmFsc2l6ZVgqdGhpcy5zY2FsZVgsIHRoaXMub3JpZ2luYWxzaXplWSp0aGlzLnNjYWxlWV07XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IG9yaWdpbmFsc2l6ZSgpIHtcclxuICAgICAgICByZXR1cm4gW3RoaXMub3JpZ2luYWxzaXplWCwgdGhpcy5vcmlnaW5hbHNpemVZXTtcclxuICAgIH1cclxuXHJcbiAgICBzZXQgb3JpZ2luYWxzaXplKG9yaWdpbmFsc2l6ZSkge1xyXG4gICAgICAgIGlmKCAob3JpZ2luYWxzaXplIGluc3RhbmNlb2YgQXJyYXkpICYmIChvcmlnaW5hbHNpemUubGVuZ3RoID09IDIpICYmICh0eXBlb2Ygb3JpZ2luYWxzaXplWzBdID09ICdudW1iZXInKSAmJiAodHlwZW9mIG9yaWdpbmFsc2l6ZVsxXSA9PSAnbnVtYmVyJykgKSB7XHJcbiAgICAgICAgICAgIHRoaXMub3JpZ2luYWxzaXplWCA9IG9yaWdpbmFsc2l6ZVswXTtcclxuICAgICAgICAgICAgdGhpcy5vcmlnaW5hbHNpemVZID0gb3JpZ2luYWxzaXplWzFdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcignc2V0IEltYWdlT2JqZWN0Lm9yaWdpbmFsc2l6ZTogb3JpZ2luYWxzaXplIGlzIG5vdCBhbiBhcnJheSBvZiBzaXplIDIgdGhhdCBjb250YWlucyBudW1iZXJzLicpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBnZXQgc2NhbGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIFt0aGlzLnNjYWxlWCwgdGhpcy5zY2FsZVldO1xyXG4gICAgfVxyXG5cclxuICAgIHNldCBzY2FsZShzY2FsZSkge1xyXG4gICAgICAgIGlmKCAoc2NhbGUgaW5zdGFuY2VvZiBBcnJheSkgJiYgKHNjYWxlLmxlbmd0aCA9PSAyKSAmJiAodHlwZW9mIHNjYWxlWzBdID09ICdudW1iZXInKSAmJiAodHlwZW9mIHNjYWxlWzFdID09ICdudW1iZXInKSApIHtcclxuICAgICAgICAgICAgdGhpcy5zY2FsZVggPSBzY2FsZVswXTtcclxuICAgICAgICAgICAgdGhpcy5zY2FsZVkgPSBzY2FsZVsxXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZih0eXBlb2Ygc2NhbGUgPT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgdGhpcy5zY2FsZVggPSBzY2FsZTtcclxuICAgICAgICAgICAgdGhpcy5zY2FsZVkgPSBzY2FsZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ3NldCBJbWFnZU9iamVjdC5zY2FsZTogc2NhbGUgaXMgbm90IGFuIGFycmF5IG9mIHNpemUgMiB0aGF0IGNvbnRhaW5zIG51bWJlcnMgb3Igc2ltcGx5IGEgbnVtYmVyLicpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiogQGNsYXNzXHJcbiovXHJcbmNsYXNzIEdhbWVPYmplY3QgZXh0ZW5kcyBJbWFnZU9iamVjdCB7XHJcbiAgICAvKipcclxuICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAqL1xyXG4gICAgY29uc3RydWN0b3Ioc3ByaXRlLCBzdWJzY3JpYmVUb1JlbmRlciA9IHRydWUpIHtcclxuICAgICAgICBzdXBlcihzcHJpdGUsIHN1YnNjcmliZVRvUmVuZGVyKTtcclxuXHJcbiAgICAgICAgdGhpcy52eCA9IDA7XHJcbiAgICAgICAgdGhpcy52eSA9IDA7XHJcblxyXG4gICAgICAgIHRoaXMub3JpZ2luYWxCb3JkZXJXaWR0aCA9IHRoaXMub3JpZ2luYWxzaXplWCB8fCA2NDtcclxuICAgICAgICB0aGlzLm9yaWdpbmFsQm9yZGVySGVpZ2h0ID0gdGhpcy5vcmlnaW5hbHNpemVZIHx8IDY0O1xyXG4gICAgICAgIC8vIC8vIEJveCBjb2xpZGVyXHJcbiAgICAgICAgLy8gdGhpcy5ib3hDb2xsaWRlclNpemUgPSBbMCwgMF07XHJcbiAgICAgICAgLy8gdGhpcy5ib3hDb2xsaWRlclBvc2l0aW9uT2Zmc2V0ID0gWzAsIDBdO1xyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gdGhpcy5hY3RpdmUgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZShkZWx0YVRpbWUpIHtcclxuICAgICAgICBpZih0aGlzLmFjdGl2ZSkge1xyXG4gICAgICAgICAgICB0aGlzLnggKz0gdGhpcy52eCpkZWx0YVRpbWU7XHJcbiAgICAgICAgICAgIHRoaXMueSArPSB0aGlzLnZ5KmRlbHRhVGltZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IGJvcmRlcldpZHRoKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm9yaWdpbmFsQm9yZGVyV2lkdGgqdGhpcy5zY2FsZVg7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IGJvcmRlckhlaWdodCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5vcmlnaW5hbEJvcmRlckhlaWdodCp0aGlzLnNjYWxlWTtcclxuICAgIH1cclxuXHJcbiAgICBnZXQgb3JpZ2luYWxCb3JkZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIFt0aGlzLm9yaWdpbmFsQm9yZGVyV2lkdGgsIHRoaXMub3JpZ2luYWxCb3JkZXJIZWlnaHRdO1xyXG4gICAgfVxyXG5cclxuICAgIHNldCBvcmlnaW5hbEJvcmRlcihvcmlnaW5hbEJvcmRlcikge1xyXG4gICAgICAgIGlmKCAob3JpZ2luYWxCb3JkZXIgaW5zdGFuY2VvZiBBcnJheSkgJiYgKG9yaWdpbmFsQm9yZGVyLmxlbmd0aCA9PSAyKSAmJiAodHlwZW9mIG9yaWdpbmFsQm9yZGVyWzBdID09ICdudW1iZXInKSAmJiAodHlwZW9mIG9yaWdpbmFsQm9yZGVyWzFdID09ICdudW1iZXInKSApIHtcclxuICAgICAgICAgICAgdGhpcy5vcmlnaW5hbEJvcmRlcldpZHRoID0gb3JpZ2luYWxCb3JkZXJbMF07XHJcbiAgICAgICAgICAgIHRoaXMub3JpZ2luYWxCb3JkZXJIZWlnaHQgPSBvcmlnaW5hbEJvcmRlclsxXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ3NldCBJbWFnZU9iamVjdC5vcmlnaW5hbEJvcmRlcjogb3JpZ2luYWxCb3JkZXIgaXMgbm90IGFuIGFycmF5IG9mIHNpemUgMiB0aGF0IGNvbnRhaW5zIG51bWJlcnMuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGdldCBib3JkZXIoKSB7XHJcbiAgICAgICAgY29uc3QgYm9yZGVyUmFkaXVzID0gWysgMC41KnRoaXMub3JpZ2luYWxCb3JkZXJXaWR0aCp0aGlzLnNjYWxlWCwgMC41KnRoaXMub3JpZ2luYWxCb3JkZXJIZWlnaHQqdGhpcy5zY2FsZVldO1xyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0b3A6IHRoaXMueSArIGJvcmRlclJhZGl1c1sxXSxcclxuICAgICAgICAgICAgcmlnaHQ6IHRoaXMueCArIGJvcmRlclJhZGl1c1swXSxcclxuICAgICAgICAgICAgYm90dG9tOiB0aGlzLnkgLSBib3JkZXJSYWRpdXNbMV0sXHJcbiAgICAgICAgICAgIGxlZnQ6IHRoaXMueCAtIGJvcmRlclJhZGl1c1swXVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgaGFzQ29sbGlkZWQob3RoZXJCb3JkZXIpIHtcclxuICAgICAgICB2YXIgbXlCb3JkZXIgPSB0aGlzLmJvcmRlcjtcclxuXHJcbiAgICAgICAgcmV0dXJuIChNYXRoLm1pbihteUJvcmRlci5yaWdodCwgb3RoZXJCb3JkZXIucmlnaHQpIC0gTWF0aC5tYXgobXlCb3JkZXIubGVmdCwgb3RoZXJCb3JkZXIubGVmdCkgPj0gMCkgJiYgKE1hdGgubWluKG15Qm9yZGVyLmJvdHRvbSwgb3RoZXJCb3JkZXIuYm90dG9tKSAtIE1hdGgubWF4KG15Qm9yZGVyLnRvcCwgb3RoZXJCb3JkZXIudG9wKSA+PSAwKTtcclxuICAgIH1cclxufVxyXG4iLCJjbGFzcyBSZW5kZXIge1xyXG4gICAgY29uc3RydWN0b3IoY2FudmFzKSB7XHJcbiAgICAgICAgaWYoUmVuZGVyLmluc3RhbmNlIGluc3RhbmNlb2YgUmVuZGVyKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1JlbmRlci5jb25zdHJ1Y3RvcjogUmVuZGVyIGluc3RhbmNlIGFscmVhZHkgZXhpc3RzLicpO1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKCEoY2FudmFzIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQpKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJSZW5kZXIuY29uc3RydWN0b3I6IGdpdmVuIGNhbnZhcyBvYmplY3QgaXMgbm90IGFuIEhUTUxDYW52YXNFbGVtZW50LlwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBSZW5kZXIuaW5zdGFuY2UgPSB0aGlzO1xyXG5cclxuICAgICAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcclxuICAgICAgICB0aGlzLmNvbnRleHQyRCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcblxyXG4gICAgICAgIHRoaXMudXBkYXRlQ2FudmFzU2l6ZSgpO1xyXG5cclxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy51cGRhdGVDYW52YXNTaXplKTtcclxuXHJcbiAgICAgICAgLy8gQ29vcmRpbmF0ZSBzeXRlbS4gQXhpcyBvcmllbnRhdGlvbiB3aWxsIGJlOiBYLT5yaWdodCAsIFktPnVwXHJcbiAgICAgICAgdGhpcy5vcmlnaW5YID0gMC41O1xyXG4gICAgICAgIHRoaXMub3JpZ2luWSA9IDAuNTtcclxuXHJcbiAgICAgICAgdGhpcy5jb29yZE9mZnNldFggPSAwO1xyXG4gICAgICAgIHRoaXMuY29vcmRPZmZzZXRZID0gMDtcclxuXHJcbiAgICAgICAgdGhpcy5vYmplY3RTZXQgPSBuZXcgU2V0KCk7XHJcblxyXG4gICAgICAgIHRoaXMuZHJhd1RpbGVHcmlkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5kcmF3Qm9yZGVycyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuZHJhd1RpbGVIaWdobGlnaHQgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBjYW52YXNQb3NpdGlvblRvUmVuZGVyQ29vcmRpbmF0ZXMocG9zaXRpb24pIHtcclxuICAgICAgICBpZiggKHBvc2l0aW9uIGluc3RhbmNlb2YgQXJyYXkpICYmIChwb3NpdGlvbi5sZW5ndGggPT0gMikgJiYgKHR5cGVvZiBwb3NpdGlvblswXSA9PSAnbnVtYmVyJykgJiYgKHR5cGVvZiBwb3NpdGlvblsxXSA9PSAnbnVtYmVyJykgKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlYWxPcmlnaW4gPSB0aGlzLnJlYWxPcmlnaW47XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAgICAgcG9zaXRpb25bMF0gLSByZWFsT3JpZ2luWzBdLFxyXG4gICAgICAgICAgICAgICAgcmVhbE9yaWdpblsxXSAtIHBvc2l0aW9uWzFdXHJcbiAgICAgICAgICAgIF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdzZXQgUmVuZGVyLmNhbnZhc1Bvc2l0aW9uVG9SZW5kZXJDb29yZGluYXRlczogcG9zaXRpb24gaXMgbm90IGFuIGFycmF5IG9mIHNpemUgMiB0aGF0IGNvbnRhaW5zIG51bWJlcnMuJyk7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBtb3VzZVBvc2l0aW9uVG9DYW52YXNSZWxhdGl2ZVBvc2l0aW9uKG1vdXNlUG9zaXRpb24pIHtcclxuICAgICAgICBjb25zdCBjYW52YXNSZWN0ID0gdGhpcy5jYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcblxyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIG1vdXNlUG9zaXRpb25bMF0gLSBjYW52YXNSZWN0LmxlZnQsXHJcbiAgICAgICAgICAgIG1vdXNlUG9zaXRpb25bMV0gLSBjYW52YXNSZWN0LnRvcFxyXG4gICAgICAgIF07XHJcbiAgICB9XHJcblxyXG4gICAgbW91c2VQb3NpdGlvblRvUmVuZGVyQ29vcmRpbmF0ZXMobW91c2VQb3NpdGlvbikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNhbnZhc1Bvc2l0aW9uVG9SZW5kZXJDb29yZGluYXRlcyh0aGlzLm1vdXNlUG9zaXRpb25Ub0NhbnZhc1JlbGF0aXZlUG9zaXRpb24obW91c2VQb3NpdGlvbikpO1xyXG4gICAgfVxyXG5cclxuICAgIG1vdXNlUG9zaXRpb25Ub1RpbGVDb29yZGluYXRlcyhtb3VzZVBvc2l0aW9uKSB7XHJcbiAgICAgICAgaWYoIVRlcnJhaW4pIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcignUmVuZGVyLm1vdXNlUG9zaXRpb25Ub1RpbGVDb29yZGluYXRlczogVGVycmFpbiBjbGFzcyBpcyBub3QgZGVmaW5lZC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZighKHRoaXMudGVycmFpbiBpbnN0YW5jZW9mIFRlcnJhaW4pKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1JlbmRlci5tb3VzZVBvc2l0aW9uVG9UaWxlQ29vcmRpbmF0ZXM6IHRlcnJhaW4gaXMgbm90IHNldC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlYWxPcmlnaW4gPSB0aGlzLnJlYWxPcmlnaW47XHJcbiAgICAgICAgICAgIGNvbnN0IHJlbGF0aXZlQ2FudmFzUG9zaXRpb24gPSB0aGlzLm1vdXNlUG9zaXRpb25Ub0NhbnZhc1JlbGF0aXZlUG9zaXRpb24obW91c2VQb3NpdGlvbik7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBjb29yZGluYXRlcyA9IFtcclxuICAgICAgICAgICAgICAgIDAuNSArIChyZWxhdGl2ZUNhbnZhc1Bvc2l0aW9uWzBdIC0gcmVhbE9yaWdpblswXSkvdGhpcy50ZXJyYWluLnRpbGVTaXplWCxcclxuICAgICAgICAgICAgICAgIC0wLjUgKyAocmVhbE9yaWdpblsxXSAtIHJlbGF0aXZlQ2FudmFzUG9zaXRpb25bMV0pL3RoaXMudGVycmFpbi50aWxlU2l6ZVlcclxuICAgICAgICAgICAgXTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgICAgICBNYXRoLmZsb29yKGNvb3JkaW5hdGVzWzBdKSxcclxuICAgICAgICAgICAgICAgIE1hdGguY2VpbChjb29yZGluYXRlc1sxXSlcclxuICAgICAgICAgICAgXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IG9yaWdpbigpIHtcclxuICAgICAgICByZXR1cm4gW3RoaXMub3JpZ2luWCwgdGhpcy5vcmlnaW5ZXTtcclxuICAgIH1cclxuXHJcbiAgICBzZXQgb3JpZ2luKG9yaWdpbikge1xyXG4gICAgICAgIGlmKCAob3JpZ2luIGluc3RhbmNlb2YgQXJyYXkpICYmIChvcmlnaW4ubGVuZ3RoID09IDIpICYmICh0eXBlb2Ygb3JpZ2luWzBdID09ICdudW1iZXInKSAmJiAodHlwZW9mIG9yaWdpblsxXSA9PSAnbnVtYmVyJykgKSB7XHJcbiAgICAgICAgICAgIHRoaXMub3JpZ2luWCA9IG9yaWdpblswXTtcclxuICAgICAgICAgICAgdGhpcy5vcmlnaW5ZID0gb3JpZ2luWzFdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcignc2V0IFJlbmRlci5vcmlnaW46IG9yaWdpbiBpcyBub3QgYW4gYXJyYXkgb2Ygc2l6ZSAyIHRoYXQgY29udGFpbnMgbnVtYmVycy4nKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IGNvb3JkT2Zmc2V0KCkge1xyXG4gICAgICAgIHJldHVybiBbdGhpcy5jb29yZE9mZnNldFgsIHRoaXMuY29vcmRPZmZzZXRZXTtcclxuICAgIH1cclxuXHJcbiAgICBzZXQgY29vcmRPZmZzZXQoY29vcmRPZmZzZXQpIHtcclxuICAgICAgICBpZiggKGNvb3JkT2Zmc2V0IGluc3RhbmNlb2YgQXJyYXkpICYmIChjb29yZE9mZnNldC5sZW5ndGggPT0gMikgJiYgKHR5cGVvZiBjb29yZE9mZnNldFswXSA9PSAnbnVtYmVyJykgJiYgKHR5cGVvZiBjb29yZE9mZnNldFsxXSA9PSAnbnVtYmVyJykgKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29vcmRPZmZzZXRYID0gY29vcmRPZmZzZXRbMF0udG9GaXhlZCgpO1xyXG4gICAgICAgICAgICB0aGlzLmNvb3JkT2Zmc2V0WSA9IGNvb3JkT2Zmc2V0WzFdLnRvRml4ZWQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ3NldCBSZW5kZXIuY29vcmRPZmZzZXQ6IGNvb3JkT2Zmc2V0IGlzIG5vdCBhbiBhcnJheSBvZiBzaXplIDIgdGhhdCBjb250YWlucyBudW1iZXJzLicpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBnZXQgcmVhbE9yaWdpbigpIHtcclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICB0aGlzLm9yaWdpblgqdGhpcy5jYW52YXMud2lkdGggKyB0aGlzLmNvb3JkT2Zmc2V0WCxcclxuICAgICAgICAgICAgKDEgLSB0aGlzLm9yaWdpblkpKnRoaXMuY2FudmFzLmhlaWdodCAtIHRoaXMuY29vcmRPZmZzZXRZXHJcbiAgICAgICAgXTtcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVDYW52YXNTaXplKCkge1xyXG4gICAgICAgIGNvbnN0IGNvbnRhaW5lclN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5jYW52YXMucGFyZW50RWxlbWVudCk7XHJcblxyXG4gICAgICAgIHRoaXMuY2FudmFzLndpZHRoID0gcGFyc2VGbG9hdChjb250YWluZXJTdHlsZS53aWR0aCkgLSBwYXJzZUZsb2F0KGNvbnRhaW5lclN0eWxlLnBhZGRpbmdMZWZ0KSAtIHBhcnNlRmxvYXQoY29udGFpbmVyU3R5bGUucGFkZGluZ1JpZ2h0KSAtIHBhcnNlRmxvYXQoY29udGFpbmVyU3R5bGUuYm9yZGVyTGVmdFdpZHRoKSAtIHBhcnNlRmxvYXQoY29udGFpbmVyU3R5bGUuYm9yZGVyUmlnaHRXaWR0aCk7XHJcbiAgICAgICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gcGFyc2VGbG9hdChjb250YWluZXJTdHlsZS5oZWlnaHQpIC0gcGFyc2VGbG9hdChjb250YWluZXJTdHlsZS5wYWRkaW5nVG9wKSAtIHBhcnNlRmxvYXQoY29udGFpbmVyU3R5bGUucGFkZGluZ0JvdHRvbSkgLSBwYXJzZUZsb2F0KGNvbnRhaW5lclN0eWxlLmJvcmRlclRvcFdpZHRoKSAtIHBhcnNlRmxvYXQoY29udGFpbmVyU3R5bGUuYm9yZGVyQm90dG9tV2lkdGgpO1xyXG4gICAgfVxyXG5cclxuICAgIHJlZ2lzdGVyT2JqZWN0KGltYWdlT2JqZWN0KSB7XHJcbiAgICAgICAgaWYoIUltYWdlT2JqZWN0KSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1JlbmRlci5yZWdpc3Rlck9iamVjdDogSW1hZ2VPYmplY3QgY2xhc3MgaXMgbm90IGRlZmluZWQuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYoIShpbWFnZU9iamVjdCBpbnN0YW5jZW9mIEltYWdlT2JqZWN0KSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdSZW5kZXIucmVnaXN0ZXJPYmplY3Q6IGltYWdlT2JqZWN0IGlzIG5vdCBhIEltYWdlT2JqZWN0IG9iamVjdC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMub2JqZWN0U2V0LmFkZChpbWFnZU9iamVjdCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHNldFRlcnJhaW4odGVycmFpbikge1xyXG4gICAgICAgIGlmKCFUZXJyYWluKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1JlbmRlci5zZXRUZXJyYWluOiBUZXJyYWluIGNsYXNzIGlzIG5vdCBkZWZpbmVkLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmKCEodGVycmFpbiBpbnN0YW5jZW9mIFRlcnJhaW4pKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1JlbmRlci5zZXRUZXJyYWluOiB0ZXJyYWluIGlzIG5vdCBhIFRlcnJhaW4gb2JqZWN0LicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy50ZXJyYWluID0gdGVycmFpbjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmVuZGVyKCkge1xyXG4gICAgICAgIHRoaXMuY29udGV4dDJELmNsZWFyUmVjdCgwLCAwLCB0aGlzLmNhbnZhcy53aWR0aCwgdGhpcy5jYW52YXMuaGVpZ2h0KTtcclxuXHJcbiAgICAgICAgdGhpcy5yZW5kZXJUZXJyYWluKCk7XHJcblxyXG4gICAgICAgIGlmKHRoaXMuZHJhd1RpbGVHcmlkKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyVGlsZUdyaWQoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMucmVuZGVyT2JqZWN0cygpO1xyXG4gICAgfVxyXG5cclxuICAgIHJlbmRlclRlcnJhaW4oKSB7XHJcbiAgICAgICAgY29uc3QgcmVhbE9yaWdpbiA9IHRoaXMucmVhbE9yaWdpbjtcclxuXHJcbiAgICAgICAgdGhpcy5jb250ZXh0MkQuZmlsbFN0eWxlID0gJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC40KSc7XHJcblxyXG4gICAgICAgIGlmKHRoaXMudGVycmFpbikge1xyXG4gICAgICAgICAgICBmb3IoY29uc3QgdGlsZSBvZiB0aGlzLnRlcnJhaW4udGlsZXMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRpbGVQb3NpdGlvbiA9IFtcclxuICAgICAgICAgICAgICAgICAgICAocmVhbE9yaWdpblswXSArICh0aWxlLnJvdyAtIDAuNSkqdGhpcy50ZXJyYWluLnRpbGVTaXplWCkudG9GaXhlZCgpLFxyXG4gICAgICAgICAgICAgICAgICAgIChyZWFsT3JpZ2luWzFdIC0gKHRpbGUuY29sdW1uICsgMC41KSp0aGlzLnRlcnJhaW4udGlsZVNpemVZKS50b0ZpeGVkKClcclxuICAgICAgICAgICAgICAgIF07XHJcblxyXG4gICAgICAgICAgICAgICAgaWYodGlsZS5zcHJpdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQyRC5kcmF3SW1hZ2UoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbGUuc3ByaXRlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aWxlUG9zaXRpb25bMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbGVQb3NpdGlvblsxXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMudGVycmFpbi50aWxlU2l6ZVgpLnRvRml4ZWQoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMudGVycmFpbi50aWxlU2l6ZVkpLnRvRml4ZWQoKVxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5kcmF3VGlsZUhpZ2hsaWdodCAmJiB0aWxlLmhpZ2hsaWdodGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0MkQuZmlsbFJlY3QoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbGVQb3NpdGlvblswXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGlsZVBvc2l0aW9uWzFdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAodGhpcy50ZXJyYWluLnRpbGVTaXplWCkudG9GaXhlZCgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAodGhpcy50ZXJyYWluLnRpbGVTaXplWSkudG9GaXhlZCgpXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZW5kZXJPYmplY3RzKCkge1xyXG4gICAgICAgIGNvbnN0IHJlYWxPcmlnaW4gPSB0aGlzLnJlYWxPcmlnaW47XHJcblxyXG4gICAgICAgIGxldCBvYmplY3RTaXplLCBvYmplY3RCb3JkZXI7XHJcblxyXG4gICAgICAgIHRoaXMuY29udGV4dDJELnN0cm9rZVN0eWxlID0gJ3B1cnBsZSc7XHJcbiAgICAgICAgdGhpcy5jb250ZXh0MkQubGluZVdpZHRoID0gMjtcclxuXHJcbiAgICAgICAgZm9yKGNvbnN0IG9iamVjdFRvUmVuZGVyIG9mIF8uc29ydEJ5KFsuLi50aGlzLm9iamVjdFNldF0sICdsYXllcicpKSB7XHJcbiAgICAgICAgICAgIG9iamVjdFNpemUgPSBvYmplY3RUb1JlbmRlci5zaXplO1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRleHQyRC5kcmF3SW1hZ2UoXHJcbiAgICAgICAgICAgICAgICBvYmplY3RUb1JlbmRlci5zcHJpdGUsXHJcbiAgICAgICAgICAgICAgICAocmVhbE9yaWdpblswXSArIG9iamVjdFRvUmVuZGVyLnggLSBvYmplY3RUb1JlbmRlci5waXZvdFgqb2JqZWN0U2l6ZVswXSkudG9GaXhlZCgpLFxyXG4gICAgICAgICAgICAgICAgKHJlYWxPcmlnaW5bMV0gLSAob2JqZWN0VG9SZW5kZXIueSArICgxIC0gb2JqZWN0VG9SZW5kZXIucGl2b3RZKSpvYmplY3RTaXplWzFdKSkudG9GaXhlZCgpLFxyXG4gICAgICAgICAgICAgICAgKG9iamVjdFNpemVbMF0pLnRvRml4ZWQoKSxcclxuICAgICAgICAgICAgICAgIChvYmplY3RTaXplWzFdKS50b0ZpeGVkKClcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIGlmKHRoaXMuZHJhd0JvcmRlcnMpIHtcclxuICAgICAgICAgICAgICAgIGlmKCFHYW1lT2JqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignUmVuZGVyLnJlbmRlck9iamVjdHM6IEdhbWVPYmplY3QgY2xhc3Mgbm90IGRlZmluZWQuJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKChvYmplY3RUb1JlbmRlciBpbnN0YW5jZW9mIEdhbWVPYmplY3QpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0Qm9yZGVyID0gb2JqZWN0VG9SZW5kZXIuYm9yZGVyO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dDJELnN0cm9rZVJlY3QocmVhbE9yaWdpblswXSArIG9iamVjdEJvcmRlci5sZWZ0LCByZWFsT3JpZ2luWzFdIC0gb2JqZWN0Qm9yZGVyLnRvcCwgb2JqZWN0VG9SZW5kZXIuYm9yZGVyV2lkdGgsIG9iamVjdFRvUmVuZGVyLmJvcmRlckhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmVuZGVyVGlsZUdyaWQoKSB7XHJcbiAgICAgICAgaWYodGhpcy50ZXJyYWluKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGV4dDJELnN0cm9rZVN0eWxlID0gJ3doaXRlJztcclxuICAgICAgICAgICAgdGhpcy5jb250ZXh0MkQubGluZVdpZHRoID0gMTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHJlYWxPcmlnaW4gPSB0aGlzLnJlYWxPcmlnaW47XHJcblxyXG4gICAgICAgICAgICBjb25zdCBtaW5YID0gTWF0aC5jZWlsKDAuNSAtIHJlYWxPcmlnaW5bMF0vdGhpcy50ZXJyYWluLnRpbGVTaXplWCk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1heFggPSBNYXRoLmZsb29yKDAuNSArICh0aGlzLmNhbnZhcy53aWR0aCAtIHJlYWxPcmlnaW5bMF0pL3RoaXMudGVycmFpbi50aWxlU2l6ZVgpO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgbWluWSA9IE1hdGguY2VpbCgtMC41ICsgKHJlYWxPcmlnaW5bMV0gLSB0aGlzLmNhbnZhcy5oZWlnaHQpL3RoaXMudGVycmFpbi50aWxlU2l6ZVkpO1xyXG4gICAgICAgICAgICBjb25zdCBtYXhZID0gTWF0aC5mbG9vcigtMC41ICsgcmVhbE9yaWdpblsxXS90aGlzLnRlcnJhaW4udGlsZVNpemVZKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuY29udGV4dDJELmJlZ2luUGF0aCgpO1xyXG5cclxuICAgICAgICAgICAgbGV0IGxvYWNrZWRQb3NpdGlvbiA9IDA7XHJcblxyXG4gICAgICAgICAgICBmb3IobGV0IGkgPSBtaW5YOyBpIDw9IG1heFg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgbG9hY2tlZFBvc2l0aW9uID0gKHJlYWxPcmlnaW5bMF0gKyAoaSAtIDAuNSkqdGhpcy50ZXJyYWluLnRpbGVTaXplWCkudG9GaXhlZCgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0MkQubW92ZVRvKGxvYWNrZWRQb3NpdGlvbiwgMCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQyRC5saW5lVG8obG9hY2tlZFBvc2l0aW9uLHRoaXMuY2FudmFzLmhlaWdodCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZvcihsZXQgaiA9IG1pblk7IGogPD0gbWF4WTsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICBsb2Fja2VkUG9zaXRpb24gPSAocmVhbE9yaWdpblsxXSAtIChqICsgMC41KSp0aGlzLnRlcnJhaW4udGlsZVNpemVZKS50b0ZpeGVkKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQyRC5tb3ZlVG8oMCwgbG9hY2tlZFBvc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dDJELmxpbmVUbyh0aGlzLmNhbnZhcy53aWR0aCwgbG9hY2tlZFBvc2l0aW9uKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5jb250ZXh0MkQuc3Ryb2tlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbiIsImNvbnN0IEltYWdlUmVzb3VyY2VTdGF0dXMgPSB7XHJcbiAgICBJTklUSUFUSU5HOiAnSW5pdGlhdGluZycsXHJcbiAgICBGQUlMRUQ6ICdGYWlsZWQnLFxyXG4gICAgTE9BRElORzogJ0xvYWRpbmcnLFxyXG4gICAgTE9BREVEOiAnTG9hZGVkJ1xyXG59O1xyXG5cclxuY2xhc3MgSW1hZ2VSZXNvdXJjZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLnByb2dyZXNzID0gMDtcclxuICAgICAgICB0aGlzLnN0YXR1cyA9IEltYWdlUmVzb3VyY2VTdGF0dXMuSU5JVElBVElORztcclxuICAgICAgICB0aGlzLm9uTG9hZCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5vblByb2dyZXNzID0gbnVsbDtcclxuICAgICAgICB0aGlzLm9uU3RhdHVzQ2hhbmdlZCA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGdldCBJTUFHRV9TVEFUVVMoKSB7XHJcbiAgICAgICAgcmV0dXJuIEltYWdlUmVzb3VyY2VTdGF0dXM7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IGxvYWRlZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT0gSW1hZ2VSZXNvdXJjZVN0YXR1cy5MT0FERUQ7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0UHJvZ3Jlc3MocHJvZ3Jlc3MpIHtcclxuICAgICAgICB0aGlzLnByb2dyZXNzID0gcHJvZ3Jlc3M7XHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKGBJbWFnZVJlc291cmNlLnNldFByb2dyZXNzOiAke3Byb2dyZXNzfWApO1xyXG5cclxuICAgICAgICBpZih0aGlzLm9uUHJvZ3Jlc3MpIHtcclxuICAgICAgICAgICAgdGhpcy5vblByb2dyZXNzKHRoaXMucHJvZ3Jlc3MpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzZXRTdGF0dXMoc3RhdHVzKSB7XHJcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XHJcblxyXG4gICAgICAgIGlmKHRoaXMub25TdGF0dXNDaGFuZ2VkKSB7XHJcbiAgICAgICAgICAgIHRoaXMub25TdGF0dXNDaGFuZ2VkKHRoaXMuc3RhdHVzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHN3aXRjaCAodGhpcy5zdGF0dXMpIHtcclxuICAgICAgICAgICAgY2FzZSBJbWFnZVJlc291cmNlU3RhdHVzLklOSVRJQVRJTkc6XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSBJbWFnZVJlc291cmNlU3RhdHVzLkZBSUxFRDpcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBjYXNlIEltYWdlUmVzb3VyY2VTdGF0dXMuTE9BRElORzpcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBjYXNlIEltYWdlUmVzb3VyY2VTdGF0dXMuTE9BREVEOlxyXG4gICAgICAgICAgICB0aGlzLnNldFByb2dyZXNzKDEpO1xyXG4gICAgICAgICAgICBpZih0aGlzLm9uTG9hZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vbkxvYWQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHNldFRyaWdnZXJzKCkge1xyXG4gICAgICAgIGlmKHRoaXMuaW1nKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW1nLm9ubG9hZHN0YXJ0ID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdHVzKEltYWdlUmVzb3VyY2VTdGF0dXMuTE9BRElORyk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbWcub25wcm9ncmVzcyA9IHByb2dyZXNzID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb2dyZXNzID0gdGhpcy5zZXRQcm9ncmVzcyhwcm9ncmVzcyk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbWcub25sb2FkID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdHVzKEltYWdlUmVzb3VyY2VTdGF0dXMuTE9BREVEKTtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW1nLm9uZXJyb3IgPSAoZXJyb3IpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXR1cyhJbWFnZVJlc291cmNlU3RhdHVzLkZBSUxFRCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzZXRTb3VyY2Uoc291cmNlKSB7XHJcbiAgICAgICAgaWYoc291cmNlKSB7XHJcbiAgICAgICAgICAgIGlmKHNvdXJjZSBpbnN0YW5jZW9mIEltYWdlKSB7XHJcbiAgICAgICAgICAgICAgICBpZihzb3VyY2Uuc3JjKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbWFnZVNyYyA9IHNvdXJjZS5zcmM7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbWcgPSBzb3VyY2U7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmKHNvdXJjZS5jb21wbGV0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0dXMoSW1hZ2VSZXNvdXJjZVN0YXR1cy5MT0FERUQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRUcmlnZ2VycygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ltYWdlUmVzb3VyY2UgcmVxdWlyZXMgYSBwcm9wZXIgc291cmNlLicpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYodHlwZW9mIHNvdXJjZSA9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbWFnZVNyYyA9IHNvdXJjZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW1nID0gbmV3IEltYWdlKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRUcmlnZ2VycygpO1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuaW1nLnNyYyA9IHNvdXJjZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvbWlzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ltYWdlUmVzb3VyY2UgcmVxdWlyZXMgYSBwcm9wZXIgc291cmNlLicpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuY2xhc3MgUmVzb3VyY2VzIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuaW1hZ2VDYWNoZSA9IG5ldyBNYXAoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICogQG1ldGhvZCBhZGRJbWFnZSAtIEFkZCBhbiBpbWFnZSByZXNvdXJjZSBhbmQgc3RhcnRzIGxvYWRpbmcgaXQgaWYgcG9zc2libGUuXHJcbiAgICAqIEBwYXJhbSB7T2JqZWN0fHN0cmluZ30gaW1nU291cmNlIC0gaW1hZ2Ugc291cmNlLiBJdCBtYXkgYmUgYW4gaW1nIGVsZW1lbnQgb2JqZWN0IG9yIHRoZSBpbWcgdXJsIHN0cmluZy5cclxuICAgICogQHBhcmFtIHtzdHJpbmd9IFthbGlhc10gLSBpbWFnZSBhbGlhcyB1c2VkIHRvIHJldHJpZXZlIHJlc291cmNlLiBpZiBpbWdTb3VyY2UgaXMgYSBzdHJpbmcgYW5kIGFsaWFzIGlzIG5vdCBzcGVjaWZpZWQsIHRoZW4gdGhlIGFsaWFzIHdpbGwgYmUgc2V0IHRvIHRoZSBpbWdTb3VyY2UuXHJcbiAgICAqIEByZXR1cm4ge1Byb21pc3NlfSAtIHByb21pc2UgdGhhdCBmdWxsZmlsbHMgd2hlbiB0aGUgcmVzb3VyY2UgaGFzIGxvYWRlZC5cclxuICAgICovXHJcbiAgICBhZGRJbWFnZShpbWdTb3VyY2UsIGFsaWFzKSB7XHJcbiAgICAgICAgaWYoICh0eXBlb2YgaW1nU291cmNlID09ICdzdHJpbmcnKSAmJiAhYWxpYXMgKSB7XHJcbiAgICAgICAgICAgIGFsaWFzID0gaW1nU291cmNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgbmV3SW1hZ2VSZXNvdXJjZSA9IG5ldyBJbWFnZVJlc291cmNlKCk7XHJcblxyXG4gICAgICAgIGlmKCFhbGlhcykge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnUmVzb3VyY2VzLmFkZEltYWdlOiBhbGlhcyBub3Qgc2V0IGFuZCB0aHVzIHRoaXMgaW1hZ2Ugd2lsbCBub3QgYmUgY2FjaGVkIScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYodGhpcy5pbWFnZUNhY2hlLmhhcyhhbGlhcykpIHtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5hbGVydChgUmVzb3VyY2VzLmFkZEltYWdlOiBpbWFnZSBhbGlhcyBcIiR7YWxpYXN9XCIgaXMgYWxyZWFkeSBiZWluZyB1c2VkIGFuZCB3aWxsIGJlIG92ZXJ3cml0dGVuLmApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLmltYWdlQ2FjaGUuc2V0KGFsaWFzLCBuZXdJbWFnZVJlc291cmNlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBuZXdJbWFnZVJlc291cmNlLnNldFNvdXJjZShpbWdTb3VyY2UpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAbWV0aG9kIGFkZEltYWdlcyAtIFNhbWUgYXMgYWRkSW1hZ2UgYnV0IGZvciBtdWx0cGxlIGltYWdlIHJlc291cmNlcy5cclxuICAgICogQHBhcmFtIHtBcnJheX0gc291cmNlcyAtIGVhY2ggZWxlbWVudCBzaG91bGQgYmUgYW4gYXJyYXkgdGhhdCBtYXRjaGVzIHRoZSBhcmd1bWVudHMgb2YgdGhlIGFkZEltYWdlIG1ldGhvZDogW2ltZ1NvdXJjZSwgYWxpYXNdLlxyXG4gICAgKiBAcmV0dXJuIHtQcm9taXNzZX0gLSBwcm9taXNlIHRoYXQgZnVsbGZpbGxzIHdoZW4gYWxsIHJlc291cmNlcyBoYXZlIGxvYWRlZC5cclxuICAgICovXHJcbiAgICBhZGRJbWFnZXMoc291cmNlcykge1xyXG4gICAgICAgIGlmKCEoc291cmNlcyBpbnN0YW5jZW9mIEFycmF5KSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdSZXNvdXJjZXMuYWRkSW1hZ2VzOiBhcmd1bWVudCBpcyBub3QgYW4gYXJyYXknKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XHJcblxyXG4gICAgICAgIGZvcihjb25zdCBhZ3VtZW50cyBvZiBzb3VyY2VzKSB7XHJcbiAgICAgICAgICAgIGlmKGFyZ3VtZW50cyBpbnN0YW5jZW9mIEFycmF5KSB7XHJcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMuYWRkSW1hZ2UuYXBwbHkodGhpcywgYWd1bWVudHMpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2godGhpcy5hZGRJbWFnZShhZ3VtZW50cykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAbWV0aG9kIGdldEltYWdlIC0gcmV0dXJucyB0aGUgaW1nIGVsZW1lbnQgb2JqZWN0IHJlc3BlY3RpdmUgdG8gdGhlIGdpdmVuIGFsaWFzLlxyXG4gICAgKi9cclxuICAgIGdldEltYWdlKGFsaWFzKSB7XHJcbiAgICAgICAgY29uc3QgY2FjaGUgPSB0aGlzLmltYWdlQ2FjaGUuZ2V0KGFsaWFzKTtcclxuXHJcbiAgICAgICAgaWYoIWNhY2hlKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1Jlc291cmNlcy5nZXRJbWFnZTogY291bGQgbm90IGZpbmQgYWxpYXMgXCIke2FsaWFzfVwiJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gY2FjaGU7XHJcbiAgICB9XHJcbn1cclxuIiwiY2xhc3MgVGlsZSB7XHJcbiAgICBjb25zdHJ1Y3Rvcihyb3csIGNvbHVtbiwgc3ByaXRlKSB7XHJcbiAgICAgICAgaWYoc3ByaXRlIGluc3RhbmNlb2YgSW1hZ2UpIHtcclxuICAgICAgICAgICAgdGhpcy5zcHJpdGUgPSBzcHJpdGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYoc3ByaXRlKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1RpbGUuY29uc3RydWN0b3I6IHNwcml0ZSBpcyBub3QgYSBJbWFnZSBvYmplY3QuJyk7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcm93ID0gTnVtYmVyKHJvdy50b0ZpeGVkKCkpO1xyXG4gICAgICAgIGNvbHVtbiA9IE51bWJlcihjb2x1bW4udG9GaXhlZCgpKTtcclxuXHJcbiAgICAgICAgaWYoICh0eXBlb2Ygcm93ID09ICdudW1iZXInKSAmJiAodHlwZW9mIGNvbHVtbiA9PSAnbnVtYmVyJykgKSB7XHJcbiAgICAgICAgICAgIHRoaXMucm93ID0gcm93O1xyXG4gICAgICAgICAgICB0aGlzLmNvbHVtbiA9IGNvbHVtbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1RpbGUuY29uc3RydWN0b3I6IHJvdyBhbmQgY29sdW1uIG11c3QgYmUgbnVtYmVycy4nKTtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmhpZ2hsaWdodGVkID0gZmFsc2U7XHJcbiAgICB9XHJcbn1cclxuXHJcbmNsYXNzIFRlcnJhaW4ge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy50aWxlU2l6ZVggPSA2NDtcclxuICAgICAgICB0aGlzLnRpbGVTaXplWSA9IDY0O1xyXG5cclxuICAgICAgICB0aGlzLnRpbGVNYXAgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy50aWxlSGlnaGxpZ2h0TWFwID0gbmV3IE1hcCgpO1xyXG4gICAgfVxyXG5cclxuICAgIGdldCB0aWxlcygpIHtcclxuICAgICAgICByZXR1cm4gWy4uLnRoaXMudGlsZU1hcC52YWx1ZXMoKV07XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IHRpbGVTaXplKCkge1xyXG4gICAgICAgIHJldHVybiBbdGhpcy50aWxlU2l6ZVgsIHRoaXMudGlsZVNpemVZXTtcclxuICAgIH1cclxuXHJcbiAgICBzZXQgdGlsZVNpemUodGlsZVNpemUpIHtcclxuICAgICAgICBpZiggKHRpbGVTaXplIGluc3RhbmNlb2YgQXJyYXkpICYmICh0aWxlU2l6ZS5sZW5ndGggPT0gMikgJiYgKHR5cGVvZiB0aWxlU2l6ZVswXSA9PSAnbnVtYmVyJykgJiYgKHR5cGVvZiB0aWxlU2l6ZVsxXSA9PSAnbnVtYmVyJykgKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGlsZVNpemVYID0gdGlsZVNpemVbMF07XHJcbiAgICAgICAgICAgIHRoaXMudGlsZVNpemVZID0gdGlsZVNpemVbMV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdzZXQgVGVycmFpbi50aWxlU2l6ZTogdGlsZVNpemUgaXMgbm90IGFuIGFycmF5IG9mIHNpemUgMiB0aGF0IGNvbnRhaW5zIG51bWJlcnMuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICBzZXRUaWxlKHRpbGUpIHtcclxuICAgICAgICBpZighKHRpbGUgaW5zdGFuY2VvZiBUaWxlKSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdUZXJyYWluLnNldFRpbGU6IHRpbGUgaXMgbm90IGEgVGlsZSBvYmplY3QuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnRpbGVNYXAuc2V0KGAke3RpbGUucm93fXgke3RpbGUuY29sdW1ufWAsIHRpbGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzZXRUaWxlcyh0aWxlcykge1xyXG4gICAgICAgIGlmKCEodGlsZXMgaW5zdGFuY2VvZiBBcnJheSkpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcignVGVycmFpbi5zZXRUaWxlczogdGlsZXMgaXMgbm90IGFuIEFycmF5LicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZm9yKGNvbnN0IHRpbGUgb2YgdGlsZXMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0VGlsZSh0aWxlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzZXRUaWxlSGlnaGxpZ2h0KHJvdywgY29sdW1uLCBoaWdobGlnaHRlZCA9IHRydWUpIHtcclxuICAgICAgICBpZiggKHR5cGVvZiByb3cgPT0gJ251bWJlcicpICYmICh0eXBlb2YgY29sdW1uID09ICdudW1iZXInKSAmJiAodHlwZW9mIGhpZ2hsaWdodGVkID09ICdib29sZWFuJykgKSB7XHJcbiAgICAgICAgICAgIGxldCB0aWxlID0gdGhpcy50aWxlTWFwLmdldChgJHtyb3d9eCR7Y29sdW1ufWApO1xyXG4gICAgICAgICAgICBpZighdGlsZSkge1xyXG4gICAgICAgICAgICAgICAgdGlsZSA9IG5ldyBUaWxlKHJvdywgY29sdW1uKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0VGlsZSh0aWxlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGlsZS5oaWdobGlnaHRlZCA9IGhpZ2hsaWdodGVkO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRpbGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdUZXJyYWluLnNldFRpbGVIaWdobGlnaHQ6IHJvdyBhbmQgY29sdW1uIG11c3QgYmUgbnVtYmVycyBhbmQgaGlnaGxpZ2h0ZWQgbXVzdCBiZSBhIGJvb2xlYW4uJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxufVxyXG4iXX0=
